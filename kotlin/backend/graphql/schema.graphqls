schema {
  query: Query
  mutation: Mutation
}

scalar LocalDateTime

enum SocialService {
  Instagram

  Twitter

  LinkedIn

  Facebook

  Other
}

type DayHeader implements ScheduleItem {
  start: LocalDateTime!

  end: LocalDateTime!

  title: String!
}

type Mutation {
  setVote(input: VoteInput!): Boolean!

  setComment(input: CommentInput!): Boolean!
}

type Query {
  sessions: [Session!]!

  """
   null if the session doesn't exist.
  """
  session(id: ID!): Session

  """
   Returns a list of ScheduleItems to be displayed in the UI.

   ScheduleItems introduce day headers as well as time headers.
   They also make sure the sessions are sorted by start time/room and group them by time slot.

   A time slot is a manually configured time range. It usually corresponds to a 30-minute slot where 3 sessions can happen in parallel.
   Because some sessions are shorter, several of them may fit into a single time slot.

   ScheduleItems also filter out some
  """
  scheduleItems: [ScheduleItem!]!

  speakers: [Speaker!]!

  """
   null if the speaker doesn't exist.
  """
  speaker(id: ID!): Speaker

  timezone: String!
}

type Room {
  name: String!

  rank: Int!

  floor: Int!
}

type Session implements ScheduleItem {
  title: String!

  description: String!

  start: LocalDateTime!

  end: LocalDateTime!

  event_type: String!

  event_subtype: String!

  venue: String @deprecated(reason: "Use room instead")

  id: ID!

  speakers: [Speaker!]!

  room: Room
}

type SocialUrl {
  service: SocialService!

  url: String!
}

type Speaker {
  username: String! @deprecated(reason: "Use id instead")

  company: String!

  position: String!

  name: String!

  about: String!

  location: String!

  url: String!

  years: [Int!]!

  socialUrls: [SocialUrl!]!

  id: ID!

  avatar: String!

  sessions: [Session!]!
}

type TimeHeader implements ScheduleItem {
  start: LocalDateTime!

  end: LocalDateTime!
}

interface ScheduleItem {
  start: LocalDateTime!

  end: LocalDateTime!
}

input CommentInput {
  userId: String!

  sessionId: String!

  comment: String!
}

input VoteInput {
  userId: String!

  sessionId: String!

  vote: Int!
}

type __Schema {
  description: String

  types: [__Type!]!

  queryType: __Type!

  mutationType: __Type

  subscriptionType: __Type

  directives: [__Directive!]!
}

type __Type {
  kind: __TypeKind!

  name: String

  description: String

  fields(includeDeprecated: Boolean = false): [__Field!]

  interfaces: [__Type!]

  possibleTypes: [__Type!]

  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]

  inputFields(includeDeprecated: Boolean = false): [__InputValue!]

  ofType: __Type

  specifiedByURL: String
}

enum __TypeKind {
  SCALAR

  OBJECT

  INTERFACE

  UNION

  ENUM

  INPUT_OBJECT

  LIST

  NON_NULL
}

type __Field {
  name: String!

  description: String

  args(includeDeprecated: Boolean = false): [__InputValue!]!

  type: __Type!

  isDeprecated: Boolean!

  deprecationReason: String
}

type __InputValue {
  name: String!

  description: String

  type: __Type!

  defaultValue: String

  isDeprecated: Boolean!

  deprecationReason: String
}

type __EnumValue {
  name: String!

  description: String

  isDeprecated: Boolean!

  deprecationReason: String
}

type __Directive {
  name: String!

  description: String

  locations: [__DirectiveLocation!]!

  args(includeDeprecated: Boolean = false): [__InputValue!]!

  isRepeatable: Boolean!
}

enum __DirectiveLocation {
  QUERY

  MUTATION

  SUBSCRIPTION

  FIELD

  FRAGMENT_DEFINITION

  FRAGMENT_SPREAD

  INLINE_FRAGMENT

  VARIABLE_DEFINITION

  SCHEMA

  SCALAR

  OBJECT

  FIELD_DEFINITION

  ARGUMENT_DEFINITION

  INTERFACE

  UNION

  ENUM

  ENUM_VALUE

  INPUT_OBJECT

  INPUT_FIELD_DEFINITION
}

directive @skip (if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

directive @include (if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

directive @deprecated (reason: String! = "No longer supported") on FIELD_DEFINITION|ARGUMENT_DEFINITION|INPUT_FIELD_DEFINITION|ENUM_VALUE

directive @defer (label: String, if: Boolean! = true) on FRAGMENT_SPREAD|INLINE_FRAGMENT

directive @specifiedBy (url: String!) on SCALAR
